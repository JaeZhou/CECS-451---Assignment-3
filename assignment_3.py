# -*- coding: utf-8 -*-
"""Assignment 3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19K1ylWARad6AEphgzvH8ToGoavok7FLK
"""

#GENETIC ALGO

import board
import random
import time

STATE_NUM = 8

class State:
  def __init__(self):
    self.boardObj = board.Board(5)
    #FITNESS
    self.boardObj.fitness()

    self.state = self.boardObj.getStringRep()
    self.fitness = self.boardObj.get_fit()
    self.normalized = 0

  def __lt__(self, other):
    return self.normalized < other.normalized

  def addNorm(self, n):
    self.normalized = n


# Generate the starting boards
states = []
for i in range(STATE_NUM):
  a = State()
  a.boardObj.fitness()
  states.append(a)

print("Starting Boards:")
for s in states:
  s.boardObj.show()

def genetic():
  run = 0
  while True:
    # Found the solution
    for s in states:
      if s.boardObj.get_fit() == 0:
        return s, run

    fitSum = 0
    # Calculate the total of the fitness values
    for s in states:
      fitSum += s.boardObj.get_fit()
      

    #SELECTION
    for s in states:
      a = (s.boardObj.get_fit()/fitSum)
      s.addNorm(a)
    # Sort the array from lowest to highest normalized value
    states.sort()

    selection = []
    for i in range(STATE_NUM):
      r = random.random()

      if r < states[0].normalized:
        selection.append(states[7])
      elif r < states[0].normalized + states[1].normalized:
        selection.append(states[6])
      elif r < states[0].normalized + states[1].normalized + states[2].normalized:
        selection.append(states[5])
      elif r < states[0].normalized + states[1].normalized + states[2].normalized + states[3].normalized:
        selection.append(states[4])
      elif r < states[0].normalized + states[1].normalized + states[2].normalized + states[3].normalized + states[4].normalized:
        selection.append(states[3])
      elif r < states[0].normalized + states[1].normalized + states[2].normalized + states[3].normalized + states[4].normalized + states[5].normalized:
        selection.append(states[2])
      elif r < states[0].normalized + states[1].normalized + states[2].normalized + states[3].normalized + states[4].normalized + states[5].normalized + states[6].normalized:
        selection.append(states[1])
      else:
        selection.append(states[0])


    #PAIRS
    pair1 = [selection[0].boardObj.getStringRep(), selection[1].boardObj.getStringRep()]
    pair2 = [selection[2].boardObj.getStringRep(), selection[3].boardObj.getStringRep()]
    pair3 = [selection[4].boardObj.getStringRep(), selection[5].boardObj.getStringRep()]
    pair4 = [selection[6].boardObj.getStringRep(), selection[7].boardObj.getStringRep()]

    clist = []
    n = selection[0].boardObj.n_queen

    #CROSS OVER
    randIndex = random.randint(1, n - 1)
    new11 = pair1[0][0:randIndex] + pair1[1][randIndex::]
    new12 = pair1[1][0:randIndex] + pair1[0][randIndex::]

    randIndex = random.randint(1, n - 1)
    new21 = pair2[0][0:randIndex] + pair2[1][randIndex::]
    new22 = pair2[1][0:randIndex] + pair2[0][randIndex::]

    randIndex = random.randint(1, n - 1)
    new31 = pair3[0][0:randIndex] + pair3[1][randIndex::]
    new32 = pair3[1][0:randIndex] + pair3[0][randIndex::]

    randIndex = random.randint(1, n - 1)
    new41 = pair4[0][0:randIndex] + pair4[1][randIndex::]
    new42 = pair4[1][0:randIndex] + pair4[0][randIndex::]

    clist.append(new11)
    clist.append(new12)
    clist.append(new21)
    clist.append(new22)
    clist.append(new31)
    clist.append(new32)
    clist.append(new41)
    clist.append(new42)


    #MUTATION
    i = 0
    for ele in clist:
      r = random.randint(0, n)
      if r != 0:
        a = list(ele)
        a[r-1] = str(random.randint(1, n))
        ele = "".join(a)
      selection[i].boardObj.setBoardfromString(ele)
      selection[i].boardObj.fitness()
      i += 1


    state = selection.copy()
    run += 1



start = time.time()
k, r = genetic()
end = time.time()

print("\nEnding Board:")
print("Running time:", (end - start)*1000, "ms")
print("Runs:", r)
k.boardObj.show()

"""# New Section"""

import board
import time

#board state
class State:
    def __init__(self):
        #set up the State class
        self.board = board.Board(5)
        self.numberOfTries = 0
        self.maxTries = 1000
        self.state = self.board.getStringRep()
        self.notSolved = True
        self.numberOfRestarts = 0

    def hillClimbCounter(self):
        #while the board is not solved
        while self.notSolved == True:
            #if the amount of tries for the program reaches a certain point
            if self.numberOfTries > self.maxTries:
                #tell user
                print("Program stuck at try #", self.maxTries, ". Restarting.")
                #add to restart count
                self.numberOfRestarts += 1
                #create new board
                self.board = board.Board(5)
                #restart the number of tries counter
                self.numberOfTries = 0
            else:
                self.numberOfTries += 1
            #continue to check if it's not solved
            if self.notSolved == False:
                #if it is, break the while loop
                break
            else:
                #otherwise continue solving
                self.hillClimb()

    def hillClimb(self):
        #show the original board
        print("Original Board: ")
        self.board.fitness()
        self.board.show()

        #get the string representation of the queens
        currentBoard = self.board.getStringRep()
        bestBoard = self.board.getStringRep()

        #get current board's fitness
        currentFitness = self.board.fit

        #go through the map and move the queens using their string represented locations 
        #after each move check the fitness, if the fitness is lower than before then 
        #make that board the new board and continue until fitness reaches zero
        for i in range(0, len(currentBoard)):
            nextBoard = bestBoard
            for j in range(0, self.board.n_queen):
                nextBoard = "".join((nextBoard[:i], str(j), nextBoard[i + 1:]))
                self.board.setBoardfromString(nextBoard)
                self.board.fitness()
                if self.board.fit == 0:
                    print("Goal board reached.")
                    print("# of restart: ", self.numberOfRestarts)
                    self.board.show()
                    self.notSolved = False
                if self.board.fit < currentFitness and self.board.fit != 0:
                    print("Moved queen.")
                    currentFitness = self.board.fit
                    bestBoard = nextBoard
                    self.board.show()

#run the program and calculate runtime and output runtime
if __name__ == '__main__':
    startTime = time.time()
    hc = State()
    hc.hillClimbCounter()
    endTime = time.time()

    formatTime = "Running Time: {rT:.2f} ms"
    runningTime = (endTime - startTime) * 1000

    print(formatTime.format(rT = runningTime))